<!DOCTYPE html>
<html>
  <head>
    <title>Problem Solving</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, middle, title-slide

# CSCI-UA 102
## Data Structures

<br>

## Problem Solving

.author[
Instructor: Joanna Klukowska <br><br><br>
]

.license[
Copyright 2020 Joanna Klukowska. Unless noted otherwise all content is released under  a <br>
[Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/).<br>
Background image by Stewart Weiss<br>]

---
layout:true
template: default
name: section
class: inverse, middle, center

---
layout:true
template: default
name: poll
class: inverse, full-height, center, middle

---
layout:true
template: default
name: breakout
class: breakout, middle

---

layout:true
template:default
name:slide
class: slide

.bottom-left[&#169; Joanna Klukowska. CC-BY-SA.]


---


## Bracket Matching

Mathematical expressions use parenthesis to modify the order of operations.
<br>For example, $3 \times ( 5 - 7 )$ is different than $(3 \times 5) -7$.

Before evaluating an mathematical expression, we want to be able to verify
that all the parenthesis in that expression are matched properly, since
otherwise we cannot evaluate such an expression.
<br>For example,
$(3 \times (5 - 7)$ and $4 \times (( 2 - 1()$ do not make sense.



#### Problem 1

Come up with an algorithm that validates parenthesis in mathematical expressions.
The algorithm should take a string that contains the expression as input,
and report either valid (true) or invalid (false).

#### Problem 2

In programming languages parenthesis are used along with other types of brackets.
Revise your algorithm so that it can validate expressions that contains `{`,`}`,
`[`, `]` and `(`, `)`.

---

## Mystery Algorithms

What do these algorithms do?

.left-column2[
__Mystery 1:__

.box[
input: a positive integer n

output: ???

algorithm:

```
create an empty stack
while n > 0 :
    stack.push(n % 2)
    n = n / 2

while stack is not empty
     print stack.pop()

```
]]
.right-column2[
__Mystery 2:__

.box[

input: a positive integer n

output: ???

algorithm:
```
create an empty queue

queue.enqueue(0)
queue.enqueue(1)
for  i  in 0 .. n
    a = queue.dequeue()
    b = queue.dequeue()
    queue.enqueue(b)
    queue.enqueue(a + b)
    print a
```
]]

.below-column2[
Test them out with a few values of `n` to try to figure it out.
]

---

## Evaluating Math Expressions

How would you write a program to evaluate a mathematical, arithmetic expression?
For example something like this

$$ ((15/(7-(1+1)))\times3)-(2+(1+1)) $$


The code that can evaluate such expressions has to:
- find and evaluate all subexpressions that are surrounded by parenthesis;
- for each operator figure out what its operands are; this involves determining
precedence of operators (i.e. knowing the order of operations)

It turns out that it is much simpler to write code for evaluation of arithmetic
expressions when they are written in a format that lets us ignore parenthesis
and that does not depend on operator precedence.
These two ways are __prefix__ and __postfix notations__.

--
- In __prefix__ notation the operator comes __before__ its operands.
- In __postfix__ notation the operator comes __after__ its operand.

--

|infix|prefix|postfix|
|:---:|:---:|:---:|
| `2 + 5` | `+ 2 5` | `2 5 +` |
|`(2 + 4) &#215; 5` | `&#215; + 2 4 5` | `2 4 + 5 &#215;`  |
|`2 + 4 &#215; 5` | `+ 2 &#215; 4 5` | `2 4 5 &#215; +` |


---

## Prefix Notation (a.k.a. Polish Notation)

For more details and the history see the Wikipedia page at http://en.wikipedia.org/wiki/Polish_notation.

--

#### Algorithm for evaluating prefix expressions

.box[
input: string containing a valid prefix expression

output: value of the expression

```
create an empty stack

scan the given prefix expression from right to left
for each token in the input expression
  if the token is an operand then
      push it onto a stack
  else if the token is an operator then
      operand1 = pop stack
      operand2 = pop stack
      compute operand1 operator operand2
      push result onto stack

return top of stack as result
```
]

--

__Problem__

Write your own program to evaluate prefix expressions.

---

## Josephus Problem

A simply counting out game that children play goes as follows:

.small[

- a number is picked, call it K
- a direction is picked: right or left
- a child that starts is picked

- all children are in a circle and as long as there are more than 1 children in the game
they keep playing
  - the first child counts 1
  - the next child (to the right or left based on the direction) counts 2
  - the next child counts 3
  - ...
  - the next child counts K and is removed from the game
  - the next child counts 1
  - ...
  - the next child counts K and is removed from the game
  - ...

- the one remaining child wins the game
]

(The real Josephus problem is much more gruesome.)

--

#### Problem
Write a program that simulates this game. Given a number of children, the value
of K and the direction, the program should determine the winner (or rather the
position of the child that will will, assuming that child at position 0 starts
the game).








</optgroup>



    </textarea>
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
        <script type="text/javascript">
          var slideshow = remark.create();

          // Setup MathJax
          MathJax.Hub.Config({
              tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
              }
          });

          MathJax.Hub.Configured();
        </script>



  </body>
</html>
